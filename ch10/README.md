## 도메인 이벤트 발행하기

도메인 이벤트를 발행하는 이유는 **바운디드 컨텍스트간의 강결합 때문이다.**

예를들어 주문에서 주문이 취소되는 경우 환불을 처리해야한다고 하자.

주문을 취소하는것은 주문 바운디드 컨텍스트 내 주문 도메인모델의 도메인로직이다.

하지만 환불은 결제 바운디드 컨텍스트 내 결제 도메인모델의 도메인로직이다.

서로가 별도의 바운디드 컨텍스트를 갖는 이유는 애초에 둘이 공통되는 문맥자체가 없기 때문이다.

따라서 바운디드 컨텍스트간 통합을 위해 도메인서비스를 하나 만들고 그 구현을 인프라 계층에서 구현하는 방식으로 안티코럽션 계층을 구현한다.

주문 도메인모델은 도메인서비스를 주입받아 예외발생시 환불로직을 수행한다.

```java
// 도메인 계층

@Entity
public class Order {
	
	
	public void cancelOrder(CancelOrderService cancelOrderService) {
		
		// Order 상태를 업데이트한다.
        
        // cancelOrderService 의 환불 로직을 호출한다.
        try {
			cancelOrderService.refund(OrderNo orderNo);	
		} catch (Exception e) {
			// 환불 로직에 실패한 경우 주문취소도 실패해야한다.
		}
		
    }
}

public interface CancelOrderService {
	
	void refund(OrderNo orderNo);
}
```
```java
// 인프라 계층

public class RefundOrderService implements CancelOrderService {
	
	public void refund(OrderNo orderNo) {
		
		// 결제 도메인로직을 실행한다.
    }
}
```

이렇게 보면 주문 도메인 로직인 `cancelOrder` 가 주문 상태도 변경하지만 환불 로직도 함께 가지고 있다.

이말은 즉, 결제 도메인의 변경이 발생되면 주문 도메인도 변경되어야 함을 의미하고 

두 바운디드 컨텍스트간에 강한 결합이 발생된다.

이러한 경우가 빈번히 발생하고 그 특징은 **A가 발생되면 B가 발생하여야 한다는 특징을 가진다.**

**가끔은 B가 언제 시작하던지 관계없다 라는 특징도 함께 가진다.**

이러한 상황에서 사용하는것이 도메인 이벤트 발행이다.

### 이벤트 구조

이벤트는 크게 `이벤트 객체, 이벤트 발행자(디스패처), 이벤트 리스너` 로 나뉜다.

이벤트 객체는 그 클래스 이름을 통해 어떤 이벤트인지 나타내며, 이벤트 리스너가 이벤트를 처리하는데 필요한 최소한의 정보(이벤트 발행시각 등)를 담는다.

Spring 에서는 이벤트 객체는 클래스로 그냥 만들면된다.

이벤트 발행자는 이벤트 객체를 등록하고 등록된 이벤트 객체를 받을 수 있는 리스너에게 전달하는 역할을 수행한다. 

Spring 에서 이벤트 발행자는 `ApplicationEventPublisher` 로 구현이 가능하다.

이벤트 리스너는 이벤트 객체를 받아서 헨들링 하는 역할을 수행한다.

Spring 에서는 `@EventListener` 와 `@TransactionalEventListener` 를 통해 구현가능하다.

---

## 이벤트 구현하기

Spring 에서 도메인 이벤트 발행을 구현하는 방법은 크게 `동기` 방식과 `비동기` 방식이 있으며

그 종류로는 `내부 이벤트 발행 방식(동기 or 비동기)`, `메세지큐를 사용한 발행방식`, `이벤트 저장소를 활용한 REST API 콜 방식`, `이벤트 저장소를 활용한 포워더 방식` 이 있다.

### 내부 이벤트 발행방식

Spring 의 `ApplicationEventPublisher` 와 `@EventListener` 이걸로 구현하는것이다.

특히 이벤트를 리스너하는 쪽에서 `@Async` 를 사용한다면 비동기방식으로 이벤트를 처리한다.

즉, 이벤트 발행쪽의 흐름과 별도의 스레드에서 동작하기 때문에 약간의 효율성을 얻을 수 있다.

다만, 트랜잭션 측면에서 이벤트 발행자 측의 트랜잭션이 롤백되었을 때 함께 롤백되게 만들고 싶다면 기존 트랜잭션에 합류시키거나

애초에 이벤트 발행자측 트랜잭션이 커밋되지 않으면 이벤트 리스너측이 작동하지 않도록 `@TransactionalEventListener(afterCommit)` 을 사용하자.

### 메세지큐를 사용한 발행방식

RabbitMQ 나 카프카를 사용해서 별도의 프로세스 혹은 별도의 스레드에서 이벤트를 리슨하도록 구현할 수 있다.

여기서 중요한점은 외부구현기술을 사용하기 때문에, Spring 의 Transactional 경계밖에서 동작한다는 점이다.

즉, 이벤트 발행측에서 롤백이 발생하더라도 그전에 이미 메세지큐로 이벤트 메세지가 전달되었다면 ?

예를들어 주문 취소 상태로 변경된 상태값을 DB에 저장하려다가 롤백이 된다고 가정해보자.

물론 DB 에는 이전 상태로 돌아가겠지만 이미 발행된 메세지에 의해 결제의 환불로직이 발생하게 된다.

또한 메세지큐로 부터 전달받아서 환불로직을 진행하던 와중, 환불에 실패하여 트랜잭션 롤백이 이벤트 발행측까지 전달되어야 하지만

별도의 스레드나 별도의 프로세스 (같은 JVM 위가 아닌) 이벤트 발행측까지 전달되지 못한다.

전자의 경우 이벤트 발행측 롤백이 발생하면 리스너측 동작이 불가해야 하니까 `@TransactionalEventListener(afterCommit)` 으로 해결할 수 있다.

후자의 경우는 반대로 이벤트 리스너측의 예외가 발생되면 발행측 로직이 롤백되어야 하므로 **큰 트랜잭션으로 서로다른 트랜잭션을 묶어야 한다.**

### 이벤트 저장소 ?

이벤트 저장소라는 것은 이벤트 객체를 저장하기 위한 별도의 저장소를 사용하는 것을 말한다.

별도의 엔티티를 만들어서 이벤트 객체로부터 진짜 필요한 데이터만을 엔티티로 만들어 저장한다.

그러한 엔티티를 어떤방식으로 처리하냐에 따라 Rest API 방식이 있고 포워더 방식이 있다.

우선 이벤트 저장소 방식의 장점은 추후에 있을 이벤트의 순서를 보장받을 수 있다는 점이다.

### Rest API 를 통해 꺼내기

이벤트를 저장하고서 제공하는 Rest API 서버를 만든다. 

또한 해당 표현계층을 일정 주기에 맞춰 호출하여 이벤트 리스너 역할을 수행하는 클라이언트를 구현하면 된다.

### 포워더를 구현하기

포워더 서버를 구현하여 이벤트 저장소의 데이터를 주기적으로 꺼내어 곧바로 이벤트 리스너에게 전달하는 방식이다.

API 와는 달리, `이벤트 저장소로 부터 꺼내는 것과 이벤트 리스너의 역할을 하나의 클라이언트가 전부 수행한다는 점이다.`

---

## 도메인 이벤트 발행시 주의할 점

1. 이벤트 저장소 방식에서 이벤트 엔티티의 컬럼을 이벤트 객체 종류별로 모두 대응되게 하는것은 어려울수 있다.
   - 즉, 이벤트 발행자가 `Order` 인지 `Member` 인지에 대한 정보를 넣는것이 어려울 수 있다는 점이다.
2. 이벤트 재처리 방식이 무한으로 작동되어 하나의 이벤트만 지속적으로 발행되는일이 없어야 한다.
    - 예를들어 마지막으로 처리한 이벤트로 부터 다시 시도하는 경우에 계속 하나의 이벤트만 발행될 수 있다.
3. 이벤트 저장소 방식에서 이벤트 엔티티 저장하는 헨들러를 비동기로 처리하는 경우 손실될 우려를 고려해야한다.
    - 애초에 별도의 스레드에서 동작하기 때문에 Spring 의 트랜잭션 경계 밖에서 동작한다. 따라서 해당 실패로인해 이벤트저장소에 이벤트가 저장되지 못하는 경우를 고려해야 한다.
4. 이벤트의 순서를 보장해야하는 경우 일부 메세지큐는 순서를 보장하지 않을수도 있다.
5. 이벤트 재처리의 경우 같은 식별자 혹은 같은 변화를 발생시키는 이벤트가 여러번 리스너에 도착하더라도 결과값은 언제나 동일해야 한다.(멱등성 보장)
   - 예를들어 환불의 경우 같은 주문에 대한 환불요청은 한번만 진행되어야 한다.
   - 또한 이벤트로 인해 도메인의 상태가 변경되는것도 여러번 요청이 오더라도 변경된 결과를 하나로 유지해야 한다.

