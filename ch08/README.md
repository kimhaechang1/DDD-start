## 도메인모델과 잠금

다음과 같은 시나리오에서는 잠금이 필요할 수 있다.

```text
여러 트랜잭션이 동시에 열리며 하나의 자원에 대해서 조회 후 연산이 이루어 질 때, 어떠한 트랜잭션의 결과에서도 유실이 없어야 한다.

특정 자원을 단일 트랜잭션에서 엄격하게 연산했지만, 동시에 열렸던 다른 트랜잭션에서의 조회된 정보와 일치하지 않을 때

트랜잭션의 범위 밖에서도 잠금을 걸어서 공유자원에 대한 선점기능을 유지할 수 있어야 한다.
```

### 선점 잠금(비관적 락)

비관적 락은 연산결과의 유실을 방지하기 위해 다른 트랜잭션에서의 접근을 배제하는 락이다. 즉, **최종 커밋**을 인정하는 방식이다.

```sql
select for update
```
위의 sql 을 사용해서 쓰기를 위한 락을 획득하고 트랜잭션이 커밋되면 잠금도 반환된다.

장점으로는 물리적인(DB 등) 연산결과의 일관성을 보장받을 수 있다는 점이다.

따라서 **쓰기가 자주 발생하면서, 정합성이 매우 중요한 트랜잭션의 경우 비관적 락을 사용하면 좋다.**

단점으로는 서로다른 트랜잭션이 서로의 락을 해제하기를 기다리는 데드락이 발생할 수 있다는 점이다.

```text
tx1 이 resource 1 에 대해서 select for update 를 하였다. (resource 1 에 대한 베타락 획득)
tx2 가 resource 2 에 대해서 select for update 를 하였다. (resource 2 에 대한 베타락 획득)

tx1 이 resource 2 에 대한 select for update 를 시도한다. (실패, resource 2의 베타락은 아직 해제되지 못함)
tx1 은 대기상태가 된다.
tx2 는 resource 1 에 대한 select for update 를 시도한다. (실패, resource 1의 베타락은 아직 해제되지 못함)
tx2 는 대기상태가 된다.

데드락 발생
```

따라서 유한대기를 만족시킴으로서 타임아웃을 설정해야 한다.

Spring Data JPA 에서는 타임아웃을 설정하기 위해 다음을 사용할 수 있다.

```java
import org.springframework.data.jpa.repository.QueryHints;

import jakarta.persistence.QueryHint;

@QueryHints({
	@QueryHint(name = "jakarta.persistence.lock.timeout", value = "2000")
})
```
### 비선점 잠금(낙관적 락)

낙관적 락은 공유 자원에 대해서 여러 트랜잭션이 접근할 때 **최초 커밋만**을 인정하는 방식이다.

예를들어 다음과 같은 시나리오가 있다.

```text
운영자는 배송지를 확인하기 위해 주문정보를 조회한다.
운영자가 배송지를 확인하는 동안 고객이 주문정보를 조회하고 배송지를 변경한다.
운영자는 (바뀌기 전)배송지를 확인한 상태에서 주문의 상태를 상품준비중에서 발송으로 변경한다.
```
여기서 운영자 입장에서는 배송지가 바뀌었는지 알 수가 없다.

현재 자신이 갖고있는 resource 가 DB의 물리적인 resource 의 상태와 동일한지 검사 할 필요가 있기 때문이다.

그렇다고 배송지 변경에 대해서, 혹은 주문 상태 변경에 대해서 선점 잠금 방식을 사용하더라도 어짜피 읽기에 대해서는 공유가 가능하기에 의미가 없다.

즉, 선점잠금 방식으로 해결할 수 없다. 

이러한 물리적인 데이터와의 불일치 문제를 해결하기 위해 낙관적 락이라는 개념이 사용된다.

그 구현은 JPA 에서 엔티티에 `@Version` 어노테이션이 달린 컬럼을 추가하면 된다.

그러면 엔티티에 변화가 발생할 때 다음과 같은 쿼리가 발생한다.

```sql
update table set a = 'b', version = version + 1 where id = 1 and version = ?;
```
위와 같은 쿼리에서 `version` 이 일치하지 않게 되면 스프링 프레임워크가 보내는 `OptimisticLockingFailureException` 이 발생한다.

근데 위 버전 불일치는 **다른 트랜잭션에서 먼저 수정사항을 커밋해서 발생**하는 것이다.

애초에 만약 잘못된 데이터 정보로 업데이트를 요청한 경우를 막고 싶다면 **응용계층에서 검사하고 명확하게 비즈니스 예외사항으로 분리하는 것을 권장**한다.

#### 애그리거트 내부 엔티티의 변경

애그리거트는 물론 하나의 엔티티와 여러 벨류로 구성되지만 

아주 밀접한 관계에 놓인 두 엔티티로 구성될 수 있다.

`@Version` 어노테이션은 루트 엔티티에 달아놓기 때문에, 연관관계에 놓인 엔티티의 변경은 실제 변경이 아닌 논리적인 변경으로 취급된다.

이러한 상황에서 강제적인 버전 업데이트가 필요할 수 있는데, Spring Data JPA 에서는 `@Lock(LockModeType.OPTIMISTIC_FORCE_INCREMENT)` 을 통해 강제적인 업데이트를 일으킬 수 있다.

하지만 조회만하고 변경이 없더라도 업데이트 쿼리가 발생하기에 주의해야 한다.

## 오프라인 선점 잠금

트랜잭션 범위를 벗어나는 잠금을 구현하기 위해 사용된다.

예를들어 공유문서 시스템이 있고, 다른사람이 쓰고있는동안에는 나머지 사람들은 읽기만 가능하다고 가정해보자.

그러면 쓰기 페이지를 위해 조회를 하는 트랜잭션이 있을 것이고, 쓰기를 반영하는 트랜잭션이 나눠져 있을 것이다.

이러한 두 트랜잭션은 둘사이 간격이 매우 길 수도 있다.

물론 `다른사람의 쓰기를 배제한다.` 에서 쓰기락을 거는 선점 락 방식이 떠오를 수 있지만, 그것은 어디까지나 하나의 트랜잭션 동안의 잠금을 허용하는 방식이다.

이러한 오프라인 선점 잠금을 구현하기 위해서는 별도의 `Lock` 엔티티를 만들고 락 정보를 영속화 시킴으로서 구현한다.

주로 락 정보를 기입할 때 어떤 엔티티에 대한 락인지 엔티티 정보와 식별자 그리고 락 식별자를 사용한다.

---

### Appendix: MySQL 의 x-lock 과 s-lock

s-lock과 x-lock이 있는데

s-lock 은 여러 트랜잭션이 가지고 있을 수 있지만

베타락의 경우에는 db 엔진마다 다르지만 Mysql innodb 엔진을 기준으로 하나의 트랜잭션이 같은 행에 대해서 공유락을 가지고 있고 다른 트랜잭션이 해당 행에 대해 베타락을 얻으려고 한다면, 반드시 해당 행의 공유락은 해제되어야 한다.
```text
When a transaction holds a shared lock on a row, 
another transaction that requests an exclusive lock on the same row must wait until the shared lock is released.
```




