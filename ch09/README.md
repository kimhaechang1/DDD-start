## 바운디드 컨텍스트

여러 도메인들간에는 같은 의미로 사용되는 도메인모델이 있고, 다른 의미로 사용되는 도메인모델이 있을 수 있다.

예를들어 회원이라는 개념이 있을 때,

유저에서 말하는 회원과 주문에서 말하는 회원은 명칭부터가 달라진다.

유저 -> `Member`, 주문 -> `Orderer`

또한 도메인모델 구현레벨에서도 달라질수 있다.

유저 -> `Member (AggregateRoot)`, 주문 -> `Orderer (Value)`

이렇게 같은 회원의 개념을 가지더라도 사용되는 문맥에 따라 명칭과 특성이 달라지는것을 `바운디드 컨텍스트`라고 한다.

일반적으로 하나의 바운디드 컨텍스트 내에는 하나의 모델을 가지며, `모델들 사이의 관계나 특성 또한 바운디드 컨텍스트 별로 다를 수 있다.`

예를들어 `Product` 와 `Category` 라는 모델이 있을 때,

`재고 바운디드 컨텍스트`에서는 상품을 기준으로 몇개가 남았는지의 정보가 필요할 뿐이다. 

카테고리는 그렇게 중요한 개념은 아니게 된다.

하지만 `카탈로그 바운디드 컨텍스트`에서는 상품별 속한 카테고리도 알아야하고, 카테고리별 어떤 상품이 있는지도 알아야한다. 

따라서 상품과 카테고리 사이에 연관관계가 존재하게 된다.

### 바운디드 컨텍스트의 구현

바운디드 컨텍스트는 단순히 도메인모델만을 포함하는것이 아니다.

왜냐하면 바운디드 컨텍스트에는 포함된 하위 도메인모델이 있고, 도메인모델의 변경은 곧 DB나 표현계층 응용계층 등의 영향을 줄 수 있기 때문이다.

바운디드 컨텍스트를 구현하는 방법에서도 굳이 도메인모델 방식이 아닌 `서비스-DAO` 방식을 사용할 수 있다.

또한 조회와 명령 기능을 분리하는 개념인 CQRS(Command and Query Responsibility Segregation) 을 도입하여 하나의 바운디드 컨텍스트 내에 `도메인모델 방식`과 `서비스-DAO` 방식을 모두 구성할 수 있다.

### 바운디드 컨텍스트 간 통합

바운디드 컨텍스트 끼리에는 `Rest API` 나 `메세지 큐` 방식으로 통합할 수 있다.

주로 인프라 스트럭쳐에서 구현한다.

예를들어 아까전 카탈로그 바운디드 컨텍스트에서 새로 추가된 상품 추천 바운디드 컨텍스트의 기능을 사용한다고 해보자.

그리고 카탈로그 바운디드 컨텍스트의 상품조회 기능에서 상품 추천 바운디드 컨텍스트의 기능을 호출해야 한다.

이러한 도메인 로직은 도메인 서비스로서 나타낼 수 있으며, 외부기술의 구현은 인프라 계층에 담당시킬 수 있다.

```java
// 도메인 계층
public interface ProductRecommendationService {
	
	List<Product> getRecommendationsOf(id: ProductId)
} 
```
```java
// 인프라 계층
public class RecSystemClient implements ProductRecommendationService {

	public List<Product> getRecommendationsOf(ProductId id) {
		// Rest API 호출 및 변환과정
    }
	
	private List<Product> toProducts(List<RecommendationItems> items) {
		// Rest API 호출결과를 변환해주는 메소드
    }
}
```

여기까지는 RestAPI 직접 다른 바운디드 컨텍스트를 호출하여 통합하는 방법이고,

서로 간접적으로 소통하는 방법이 `메세지 큐` 방식이다.

메세지 큐 방식에서 중요한것은 **어떤 바운디드 컨텍스트가 큐를 제공하냐에 따라 전송할 데이터모델이 달라지며**, 

각각의 바운디드 컨텍스트의 `도메인에 따라 데이터모델을 다르게 정의`한다.

### 바운디드 컨텍스트 간 관계

바운디드 컨텍스트간에 메세지 큐 혹은 Rest API 로 소통하는데, 여기서 데이터를 제공하는 쪽을 상류(`upstream`) 이라고 하고 요청자 쪽을 하류 (`downstream`) 이라고 한다.

요청자에서 중요한점은 **자기자신의 바운디드 컨텍스트 내 도메인 모델이 상류쪽 모델에 의해 침범받으면 안된다.**

그것에 따라 요청자에서는 필요한 부분을 도메인서비스로 추상화하고, 그 구현을 인프라에서 구현한다.

특히 인프라계층에서는 `상류측 데이터모델을 그대로 도메인계층으로 들고오지 않고 변환을 거치게 만든다.`

이렇게 침범받지 않는 완충지대 역할을 수행하는것을 `안티 코럽션 계층(Anticorruption Layer)`이라고 한다.

또한 상류측에서는 여러 하류 바운디드 컨텍스트들과의 통합을 위해 공개 API를 만들어 서비스로 구성하는것을 `공개 호스트 서비스(Open Host Service)` 라고 한다.

```text
고객 -> 기능제공을 위해 도메인로직 호출 중 다른 바운디드 컨텍스트의 기능 호출

제공자 -> 서비스에 의해 여러 도메인 로직 수행한 결과제공

고객 -> 제공자로 부터 제공받은 모델을 그대로 쓰지않고 인프라계층에서 가공하여 도메인계층으로 들고간 후 도메인로직 마저 수행 
```

즉, 고객과 제공자간에 요청에 따른 응답이 존재한다. 요청자는 제공자에 맞게 데이터를 변환하여 요청하고

제공자는 자신의 도메인로직 수행결과의 모델을 반환한다.

고객은 해당 모델을 그대로 사용하지 않는다.

즉, `바운디드 컨텍스트간에 서로의 하위 도메인모델을 독립적으로 지켜낸다.`

만약 독립적으로 지키는것이 아닌 하나의 도메인모델을 두 바운디드 컨텍스트간에 공유할 수 있다. 이것을 `공유커널(Shared Kernel)` 방식이라고 한다. 

마지막으로 직접 수동적으로 통합하는 방식을 `독립 방식(Seperate Way)` 라고 한다.

### 컨텍스트 맵

여러 바운디드 컨텍스트간에 도메인 모델 깊이로 시스템을 관찰하려하면 복잡성이 너무 높아진다.

따라서 바운디드 컨텍스트 간에 어떤 `ACL(안티코럽션 계층)` 과 `OHS(오픈 호스트 서비스)` 관계를 가지는 나타내는 맵을 `컨텍스트 맵` 이라고 하낟.





