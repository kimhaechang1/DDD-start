## DIP 

고수준 모듈이라는 것은 하나의 명확한 기능을 실행할 수 있는 모듈을 의미한다.

예를들어 결제기능을 시행하는 `Payment` 모듈이 있다고 가정해보자.

`Payment` 모듈의 `doPay`는 회원 식별자와 제품 식별자를 통해 조회하여

회원의 등급과 제품의 타입에 따른 외부 결제모듈을 활용하여 결제를 실행한다.


```java
public class Payment {
	
	private MemberJpaRepository memberJpaRepository;
	private ProductJpaRepository productJpaRepository;
	private TossPay pay;
	
	public Receipt doPay(long memberId, long productId) {
		
		Member member = memberJpaRepository.findById(memberId);
        Product product = productJpaRepository.findById(productId);
		
		TossReceipt tossReceipt = pay.doPay();
        // tossReceipt를 통해 서비스의 영수증으로 변환과정
        return receipt;
    }
}
```

고수준인 모듈이 저수준 모듈을 직접적으로 의존하고 있다.

예를들어 `Member`나 `Product`가 더이상 `Jpa`를 사용하지 않는다고 하면?

또한 `TossPay`가 아니라 다양한 결제 대행사를 지원해야 한다면?

그때마다 infra 계층의 의존성을 추가하여 `doPay` 메소드를 지원해야 한다.

또한 `Payment`의 `doPay` 메소드만의 서비스로직에 대한 테스트를 힘들게 만든다.

왜냐하면 다른 infra 계층의 모듈들이 테스트 코드에서도 완벽히 동작가능한 상태여야하기 때문이다.

즉, Mock 객체를 만들기가 힘들다.

따라서 도메인 계층 혹은 응용계층에서 저수준의 인프라계층의 모듈을 직접 의존하지 않고서

기능을 수행할 고수준의 인터페이스를 통해 의존성을 역전시킨다.

```java
public interface MemberRepository {
	
	findById(MemberId id);
}
```
```java
public interface PaymentGateway {
	
	Receipt pay();
} 
```
**주의 할 점으로 위의 두 인터페이스는 infra 계층에서 만드는것이 아니다.**

잘못해서 infra 계층에서 만들어 버린다면, 마치 infra에서 구현하는 기술의 관점에서 만드는 인터페이스가 된다.

DIP를 위한 인터페이스는 사용자 관점(`Payment` 의 `doPay()`)에서 해당 메소드가 필요하다고 생각해야 한다.

이러면 구현객체는 infra 계층에서 담당하면 된다.

```java
public class PGToss implements PaymentGateway {
	
	private TossPay pay;
	
	public Receipt pay() {
		// 토스페이만의 결제로직
    }
}
```

```java
public class MemberJpaRepositoryImpl implements MemberRepository, JpaRepository<> {
	
	findById(MemberId id);
}
```
장점으로 위에서는 JpaRepository 를 사용했지만 MyBatis 를 사용하는 Repository로의 변경도 쉬워진다.

그저 MemberRepository 를 구현하면 되기 때문이다.

테스트 코드를 위한 Mock 객체를 만드는것도 쉽다. 그저 인터페이스를 구현하면 된다.

---

## 도메인 모델 구성요소

도메인 모델에는 `(도메인)엔티티`, `벨류`, `에그리거트`, `레포지토리`, `도메인 서비스` 가 있다.

- `에그리거트`: 관련된 엔티티와 벨류들을 묶어놓은 개념을 뜻한다. `Order` 엔티티와 `OrderLine` 벨류 그리고 `Orderer` 가 하나의 에그리거트라고 볼 수 있다
- `레포지토리`: 엔티티를 영속화 시키는 개념을 뜻한다.
- `도메인 서비스`: 기본적인 도메인 엔티티는 도메인 로직을 포함하고 있으나, 할인 계산로직과 같은 특정 엔티티에 속하기 힘든 로직을 별도 도메인 서비스로 분리할 수 있다.

흔히 엔티티라고 하면 영속화 적인 측면에서 `DB엔티티`와 `도메인 엔티티`로 구분할 수 있다.

둘은 같아 보이지만 크게 두가지 차이가 있다.

1. DB엔티티는 단순한 영속화된 데이터만을 표기하지만, 도메인 엔티티는 도메인 로직을 포함하고 있다. 도메인의 관점에서 제공할 기능을 도메인로직으로 구현하면서 내부적으로 데이터 변경은 캡슐화 한다.
2. 도메인 엔티티는 하나의 개념을 포함하는 두 가지 이상의 데이터(필드)를 벨류로 표현할 수 있다. 

### 애그리거트

에그리거트는 `루트 엔티티`가 있으며, 루트 엔티티를 기준으로 다양한 도메인 기능을 사용할 수 있다.

다른말로 하자면, 하나의 에그리거트 내에 벨류 혹은 다른 엔티티에 대한 참조가 필요할 때 루트 엔티티를 통해서만 접근 가능해야 한다.

따라서 애그리거트를 통해 도메인 모델간의 경계를 만들고 트랜잭션 범위를 지정한다.

### 레포지토리

레포지토리의 경우 도메인 엔티티는 데이터와 기능을 함께 갖고있기에 영속화 할 수 있어야 한다.

응용 계층에서 요청에 대한 기능을 제공하기 위해 도메인 모델을 가져와야 한다. 따라서 레포지토리를 통해 영속화된 도메인모델을 가져와야 한다.

따라서 레포지토리는 **기본적으로 식별자를 통한 영속화와 식별자를 통한 조회의 기능을 가지고있다.**

이 때 **도메인 모델을 가져오는 레포지토리는 추상화 되어 도메인 계층에 존재하며, 실제 인프라 계층에서 실제 DB와 같은 외부서비스와의 로직을 처리한다.**

자연스럽게 하위 계층의 인프라계층이 도메인 계층이라는 상위 계층에 의존하는 DIP 형태가 만들어진다.

레포지토리는 응용계층에서 기능을 구현할 때 트랜잭션 기능을 제공할 수 있어야 한다.

---

## 인프라스트럭처 개요

인프라스트럭처는 다른 계층들을 기술적으로 지원하는 계층이다.

영속성 처리라고만 생각할 수 있는데, 트랜잭션의 구현을 담당한다고 생각하면 되고

REST 클라이언트 요청이라던지  메일을 보낸다면 SMTP와 같은 기술적 구현체를 제공하기도 한다.

엄밀하게 도메인 엔티티와 DB엔티티를 구분하자고 한다면 순수한 도메인 모델 객체를 위해서 다른 의존성들을 다 걷어내야 한다.

그런데 그렇게 개발하면 생산성이라는 개발에 있어서 중요한 부분을 많이 포기해야 한다.

흔히 그래서 인프라스트럭쳐로 JPA를 사용했을 때, 도메인 엔티티에 `@Entity` 어노테이션과 같은 인프라 스트럭쳐의 기술을 함께 사용하기도 한다.

또한 응용계층에서 트랜잭션 처리를 편하게 하기 위해서 `@Transactional`을 사용하기도 한다.

**DIP 를 통해 얻는 테스트 용이 및 변경에 유연함을 크게 해치지 않는 선에서는 구현기술에 대한 의존성을 직접적으로 가지는것은 일부 허용하기 도 한다.**




