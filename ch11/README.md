## CQRS 패턴

도메인모델의 변경을 처리하는것은 도메인모델의 공개 메소드로 처리할 수 있다.

하지만 조회에 대한 기능은 보통 여러 애그리거트간의 협력으로 구성된다.

애그리거트들은 서로에 대해 `식별자` 혹은 `직접 참조` 의 방식으로 연관관계를 구현할 수 있다.

하지만 조회에 있어서는 둘 다 **성능상 한번의 쿼리로 해결 될 것을 여러 쿼리로 나누게 된다.**

따라서 도메인모델에 있어서는 조회를 위한 조회전용 모델이 필요하게 된다.

물론 이를 JPQL 에 있는 DTO 매핑 방식으로 구현해도 되고, `@Subselect` 방식으로 구현하여 별도의 조회전용 엔티티 모델을 사용해도 된다.

어떤 때에는 조회전용 모델은 JPA 가 아닌 MyBatis와 같은 다른 인프라 구현체를 사용하기도 하며, RDBMS를 사용하지 않고 NoSQL 을 사용하는것 처럼 DB 사용전략을 분리할 수 도 있다.

**이러한 방식을 `CQRS (Command Query Responsibility Segregation)` 라고 한다.**

CQRS 에서 `Command(명령)` 부분은 시스템의 상태를 변경하는 요청을 의미하고

`Query(조회)` 부분은 시스템의 상태를 조회하는 요청을 의미한다.

### CQRS 구조

보통 `레포지토리의 구현기술인 ORM 을 분리할 것이냐?` 혹은 `사용하는 DB 를 분리할 것이냐?` 에 따라 상세한구조가 달라지긴 하나

`Query` 는 `Command` 구조에 비해 응용계층이 사라진체로 구현하기도 한다.

왜냐하면 다른 계층으로부터의 기술적인 호출(도메인 계층 등)을 크게 조율할 것이 없기 때문이다.

따라서 `Query` 는 일반적으로 `표현계층 - 서비스 - 인프라 DAO(구현)` 으로 이루어지며, 만약 정말 단순하다면 `표현계층 - 인프라 DAO (구현)` 으로 서비스없이 설계할 수 있다.

### CQRS: 서로다른 DB를 쓰는 경우

서로다른 DB를 쓰는 경우라면 둘 사이에 동기화가 이루어져야한다.

만약 하나의 프로세스 내에서 CQRS 구현을 위해 DB 종류를 나눈경우, Spring 내부이벤트를 발행시키거나 직접 저장을 호출할 수 있다.

그것이 아니라 조회모델과 명령모델이 서로 분리된 프로세스라면 동기화를 엄격하게 해야하는가에 따라 나뉜다.

동기화가 엄격하단것은 즉각적으로 명령모델에 의한 DB 변경이 조회모델의 DB 에도 반영되어야 한단 의미이다.

따라서 하나의 글로벌 트랜잭션을 사용하여 둘 사이를 묶을 수 있지만, 어느정도의 성능포기를 감수해야 한다.

동기화가 그다지 엄격할 필요가 없다면, 메세지큐 등을 사용해서 변경사항을 전달할 수 있다.

### CQRS 의 장단점

CQRS 를 고려하지 않더라도, 일반적으로 DDD 를 사용하고 있거나 레이어드 아키텍쳐로 구현하다보면 도메인모델의 기능으로서 조회기능을 완벽하게 구현할 수 없기에 

자연스럽게 별도의 조회전용 DTO 등을 사용하거나 `@Subselect` 등을 사용하곤 한다.

CQRS 를 사용하게 되면 이러한 부분에서 구조적인 설계 용이성을 얻을 수 있고, 특히 모델적인 분리가 가능하기 때문에 예를들어 조회성능만을 따로 키우고싶거나 하는 경우에 응용이 편하다.

단점은 결국 두가지 모델을 설계해야 하기 때문에 설계 난이도가 올라갈 수 있고, 이것은 곧 기능구현 생산성에 문제를 일으킬 수 있다.

따라서 충분히 복잡한 시스템이 아니라 정말로 트래픽이 얼마없을 낮은 수준의 시스템이라면 CQRS 를 꼭 필요로하는지 고민해서 도입하자.









